# Explanation for 02.CombinationSum

Imagine you're facing a challenge where you're given a set of distinct integers, and your goal is to find all possible combinations of these integers that add up to a specific target sum. The catch here is that you can use each number as many times as you like. It's like having an unlimited supply of each candidate number, and you're tasked with filling a bag to reach the exact weight of your target.

Let's delve into an example to make this clearer: suppose your candidate numbers are 2, 3, 6, and 7, and your target sum is 7. Here, one valid combination could be using three 2s and one 3, because 2 plus 2 plus 3 equals 7. Alternatively, you could simply use one 7 since it directly achieves the target. Notice how the same numbers can be used repeatedly, allowing for these varied combinations.

To tackle this problem efficiently, we need to leverage a process known as backtracking. Backtracking is a common method used in combinatorial problems where you explore possible solutions incrementally and abandon paths that don't meet the criteria—like a maze where you backtrack upon hitting a dead end.

The strategy here involves starting with an empty list to hold our current combination and systematically exploring each number from a given position in the candidate list. From any starting number, you can choose to include it in your list and recurse, searching for the remaining target sum. This step is crucial: while deciding to pick a number, you also consider what the new target becomes by subtracting the chosen number from the current target. This recursive exploration continues until one of two things happens: either the target reaches zero, meaning you've found a valid combination, or the target dips below zero, signaling a need to abandon that path.

The elegance of backtracking in this scenario lies in its ability to handle repetition implicitly. Since each choice leads to recursive calls starting from the same or subsequent positions, it naturally accommodates using numbers multiple times.

One might initially consider a simpler brute-force method, attempting to generate all possible combinations blindly and then checking their sums. However, this would be inefficient with exponential growth in possibilities as the number of candidates and the target increase. Backtracking refines this by pruning unnecessary calculations early, stopping as soon as the path can't lead to a valid solution.

With this approach, you ensure a comprehensive exploration of possible combinations while efficiently managing computational overhead. This makes backtracking not just a solution but an optimal strategy, given the constraints and nature of the problem. As you grasp this, remember, it isn't just about finding one solution—it's about finding all possible solutions that add up to the target, showcasing the power of recursive thinking and intelligent search strategies in algorithm design.