# Explanation for 07.DecodeWays

In the Decode Ways problem, you're given a string composed solely of digits, and each digit or pair of digits can potentially be mapped to a letter from A to Z, according to a specified mapping: for example, '1' maps to 'A', '2' to 'B', and so on up to '26' mapping to 'Z'. The task at hand is to determine how many distinct ways there are to decode this string based on this mapping.

Imagine you're working with an encoded message. You can think of it as a string of numbers like "226". Each number corresponds to a letter: '2' can be 'B', '26' can be 'Z', and so on. The key is that you can choose to decode either one or two digits at a time, provided that the number falls within the valid range of 1 to 26. The challenge is to find the total number of ways you can split the string into valid segments that respect this rule.

To break down the problem, start by considering the constraints. If you encounter a digit '0', understand that it does not map to any letter directly, so any group of digits forming a valid letter cannot start with '0'. Therefore, '06' isn't valid, while '6' is. This helps manage expectations around how leading zeroes affect the decoding possibilities.

A straightforward approach might involve recursively attempting each possible split of the string, checking if each resulting segment is valid, and counting the successful paths. This, however, would be inefficient because you'd end up recalculating the number of ways to decode various substrings multiple times.

Instead, dynamic programming offers an elegant solution. You can think of solving this problem as breaking it into stages: calculate the number of ways to decode the substring starting from each index in order of increasing complexity. Imagine stepping through the string from the end to the beginning. At each step, you determine how many ways there are to parse the rest of the string starting from that point, based on whether you use one character or two.

As you progress, you'll build up a running tally of possible decodings, using previously computed results to avoid redundant calculations. For scenarios like "226", when considering how to decode starting at '6', you'd find there's one way to decode it as 'F'. Moving back to '26', you realize it can be decoded as 'Z' and adds another valid method. Finally, stepping back to '2', you bring all these possibilities together, ultimately counting how each digit or pair can branch into valid decoding sequences.

In applying dynamic programming optimally, you'd typically utilize a small array or even just a few variables to keep track of the number of ways to decode from the current character and the next two. This reduces space complexity significantly, translating the problem into a much more efficient solution both in terms of time and memory.

Ultimately, by transitioning from a recursive, brute force idea to a dynamic programming solution, you harness the power of optimal substructure and overlapping subproblems, two key concepts in computer science that allow you to solve complex problems efficiently. With the correct setup, finding the total number of ways to decode the string becomes a manageable process, yielding results with both clarity and speed.