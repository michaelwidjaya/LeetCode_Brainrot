# Explanation for 11.LongestIncreasingSubsequence

Imagine you have a sequence of numbers, and your task is to find the longest subsequence within it where each number is strictly greater than the one before it. A subsequence differs from a contiguous subarray because you can pick and choose elements from any position as long as their order remains intact. For instance, from the list [0, 3, 1, 6, 2, 2, 7], the sequence [3, 6, 7] is a valid increasing subsequence.

Now, let's consider you are given a list, and your goal is to determine the length of the longest such increasing subsequence. This problem quickly grows complex because you need to consider many potential combinations of elements that could make up an increasing sequence.

To understand the challenge, picture an array of numbers where some elements are increasing and some are not. For instance, take the list [10, 9, 2, 5, 3, 7, 101, 18]. An increasing subsequence here can be [2, 3, 7, 101], which gives us a length of 4. However, there are different potential subsequences you might find, such as [2, 5, 7, 101] or starting a sequence with [3].

Initially, a brute force approach might suggest checking all possible subsequences. However, that would be highly inefficient, especially since the number of subsequences can grow exponentially. Instead, through dynamic programming, we can create a more manageable solution. The key is to track the longest increasing subsequence we can form up to each element in the list.

You begin by considering each element as the end of a potential subsequence. For every element, consider all previous elements that could link to it in a strictly increasing manner. You then build upon the longest subsequence length found at each position by seeing if the current element can extend any of those earlier sequences longer than previously possible.

Implementing this thought process iteratively over the list results in a solution with a time complexity of O(n squared), where you assess every pair of elements once. However, to optimize even further, we aim to improve this to O(n log n) using binary search principles. The idea is to maintain an auxiliary array where each position represents the smallest possible end element of an increasing subsequence of that length. As you iterate through the list, you update this array using binary search to find where the current number should fit to maintain the smallest possible ending value for subsequences. This way, you're effectively compressing the search space by smartly determining where each number can contribute to a potential increasing subsequence.

Ultimately, understanding this problem and solving it optimally involves both recognizing patterns in subsequences and using clever data structure strategies like binary search to efficiently manage and update potential sequences. The elegance in this solution lies in mapping the problem's inherent complexity into structural mathematical operations that are computationally efficient.