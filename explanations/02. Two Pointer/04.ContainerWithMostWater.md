# Explanation for 04.ContainerWithMostWater

Imagine you have a series of vertical lines of varying heights positioned closely along a shore, like a series of wooden stakes in the sand. These lines form the potential sides of a container that can trap water, just like the sides of a large trough. Your goal is to determine which pair of lines, when connected at the base, can trap the most water.

The crucial insight here is that the amount of water a container can hold is determined by two factors: the minimum height of the two lines forming the container and the horizontal distance between them, which acts as the width. Therefore, the area of the container, and consequently the volume of water it can hold, is found by multiplying these two factors: the shorter line's height and the distance between the two lines.

Now, let's think about how to identify which pair of lines maximizes this area. Initially, it might seem like a brute-force approach, testing each possible pair of lines to calculate the water they could contain, would be necessary. However, such an approach, while intuitive, ends up being inefficient, especially when dealing with a large number of lines, as you would have to examine every possible combination.

To solve this problem more efficiently, consider the following strategy: use a two-pointer technique, with one pointer starting at the leftmost line and the other at the rightmost line. The intuition behind this is to start with the widest possible container and then look for opportunities to increase the area by adjusting either pointer in a controlled manner.

As you evaluate the container formed by these two pointers, calculate the area based on the shorter of the two lines. To potentially find a larger area, you then move the pointer pointing to the shorter line inward. Why do this? If you have two lines determining the width, the potential for increasing the area lies in increasing the height by moving past shorter lines, as the width will naturally decrease due to the narrowing space between the two pointers.

Repeat this process, continuously calculating areas and shifting pointers inwards until they meet. Through this iterative approach, you effectively scan for the largest possible container without deviating into exhaustive pair comparisons. The brilliance of this method is that it leverages the properties of the problem efficiently, allowing you to discover the solution in linear time relative to the number of lines, rather than squaring it as in a brute-force approach. This elegant solution not only highlights the power of strategic problem-solving but also exemplifies an optimal way to handle constraints in computational problems.