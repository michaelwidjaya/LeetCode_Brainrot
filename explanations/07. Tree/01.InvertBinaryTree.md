# Explanation for 01.InvertBinaryTree

Imagine you have a binary tree, which is a simple data structure where each node has up to two children, a left child and a right child. Your task is to invert this tree. Inverting here means swapping every left child with its corresponding right child. So if you imagine the tree as a sort of family hierarchy chart with each node being a person, inverting the tree means every person swaps the position of their left-handed sibling with their right-handed sibling.

To illustrate, consider a tree that starts with a root node that has two children. The left child might have its own children, as might the right child. When you invert this tree, the left child becomes the right child and vice versa. Within each subtree, this process continues down to the leaves, which are the nodes without children, swapping positions all the way.

Let's ground this with a simple example. Suppose your tree starts with a root node of value 4. This root has two children, 2 on the left and 7 on the right. The node 2 itself might have children, say nodes 1 and 3, and node 7 might have children 6 and 9. When you invert the tree, node 4 stays in place, but the left and right children swap. Node 7 moves to the left and 2 to the right. This process continues as node 7's children, 6 and 9, swap, and so do node 2's children, 1 and 3. The result is a tree that mirrors the original structure along the root axis.

The intuitive approach to solving this problem involves recursion, a method that allows us to traverse and transform each part of the tree in isolation, starting from the root and moving downwards. Recursion inherently mirrors the tree structure itself, as you tackle the root, then recursively apply the same operation to its subtrees, inverting as you go.

Think about recursion like laying down a set of dominoes â€” when you push one, it naturally affects the others. The base case of our recursion is when we hit a node that is null, meaning we've reached the end of a branch and have no more children to swap, so effectively, doing nothing is needed at that point. Each active step in our recursive process involves storing a reference to one child, then performing the swap of the children, and proceeding to recursively invert the subtrees associated with these now swapped children.

From a performance perspective, this recursive strategy is efficient. Each node needs to be visited once to swap its children and repeat the process for its children, so the time complexity is proportional to the number of nodes, which we can express as O(N), where N is the number of nodes in the tree. Regarding space complexity, the recursion will require stack space proportional to the height of the tree. In the worst case, this can be the height of the tree itself because of the recursive nature of the function calls, which aligns with O(H), where H is the height of the tree.

Invert this concept in your mind and you'll see how elegant and straightforward it is to transform a tree in such a manner, employing the power of recursion to neatly walk through and modify the tree structure as needed.